<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Session Viewer</title>
  <style>
    :root {
      --coral: #F87171;
      --coral-light: #FEE2E2;
      --coral-dark: #DC2626;
      --gray-50: #F9FAFB;
      --gray-100: #F3F4F6;
      --gray-200: #E5E7EB;
      --gray-300: #D1D5DB;
      --gray-400: #9CA3AF;
      --gray-500: #6B7280;
      --gray-600: #4B5563;
      --gray-700: #374151;
      --gray-800: #1F2937;
      --gray-900: #111827;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--gray-100);
      color: var(--gray-800);
      line-height: 1.6;
    }

    /* Header */
    .header {
      background: white;
      border-bottom: 1px solid var(--gray-200);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header h1 {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--gray-800);
    }

    .header-controls {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .session-select {
      padding: 0.5rem 1rem;
      border-radius: 6px;
      border: 1px solid var(--gray-300);
      background: white;
      color: var(--gray-700);
      font-size: 0.875rem;
      cursor: pointer;
    }

    .session-select:focus {
      outline: none;
      border-color: var(--coral);
      box-shadow: 0 0 0 3px var(--coral-light);
    }

    /* Main container */
    .container {
      width: calc(100% - 340px); /* Scale with viewport, leave room for comments */
      min-width: 400px;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
    }

    .container.has-comments {
      transform: translateX(-100px); /* Shift slightly left when comments exist */
    }

    /* Session metadata */
    .session-meta {
      background: white;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    .session-meta h2 {
      font-size: 1.125rem;
      margin-bottom: 0.5rem;
      color: var(--gray-900);
    }

    .session-meta .meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      font-size: 0.8125rem;
      color: var(--gray-500);
      margin-bottom: 0.5rem;
    }

    .session-meta .meta-row span {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .session-meta .summary {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--gray-100);
      font-size: 0.875rem;
      color: var(--gray-600);
      white-space: pre-wrap;
    }

    /* Timeline */
    .timeline {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    /* Turn cards */
    .turn {
      background: white;
      border-radius: 12px;
      padding: 1.25rem 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    .turn-header {
      margin-bottom: 0.5rem;
    }

    .turn-role {
      font-size: 0.8125rem;
      font-weight: 500;
    }

    .turn.user .turn-role {
      background: var(--coral-light);
      color: var(--coral-dark);
      padding: 0.25rem 0.625rem;
      border-radius: 4px;
      display: inline-block;
    }

    .turn.assistant .turn-role {
      font-weight: 500;
      color: #171717;
      background: #E8E8E8;
      padding: 0.25rem 0.625rem;
      border-radius: 4px;
      display: inline-block;
    }

    .turn-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .skill-badge {
      font-size: 0.75rem;
      font-weight: 500;
      padding: 0.125rem 0.5rem;
      background: #FEF3C7;
      color: #92400E;
      border-radius: 4px;
    }

    .internal-badge {
      font-size: 0.6875rem;
      font-weight: 500;
      padding: 0.125rem 0.5rem;
      background: var(--gray-200);
      color: var(--gray-500);
      border-radius: 4px;
      text-transform: lowercase;
    }

    .turn.internal {
      border-left-style: dashed;
      opacity: 0.75;
      margin-left: 1.5rem;
    }

    .turn.internal .turn-content {
      color: var(--gray-500);
    }

    /* Thinking blocks */
    .thinking-block {
      margin: 0.5rem 0;
    }

    .thinking-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.625rem 1rem;
      background: var(--gray-100);
      border: 1px dashed var(--gray-300);
      border-radius: 8px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.8125rem;
      color: var(--gray-500);
      width: 100%;
      text-align: left;
      transition: all 0.15s;
    }

    .thinking-header:hover {
      background: var(--gray-200);
      border-color: var(--gray-400);
    }

    .thinking-icon {
      font-size: 0.625rem;
      color: var(--gray-400);
    }

    .thinking-label {
      font-weight: 500;
      color: var(--gray-600);
    }

    .thinking-summary {
      color: var(--gray-400);
    }

    .thinking-content {
      margin-top: 0.5rem;
      padding-left: 1rem;
      border-left: 2px dashed var(--gray-200);
    }

    .thinking-content .turn {
      margin-bottom: 0.5rem;
    }

    .turn-timestamp {
      display: none;
    }

    .turn-content {
      font-size: 0.9375rem;
      color: var(--gray-700);
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .turn-images {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .turn-image {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
      border: 1px solid var(--gray-200);
      cursor: pointer;
      transition: transform 0.15s;
    }

    .turn-image:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .turn.user {
      border-left: 3px solid var(--coral);
      background: white;
    }

    .turn.user.bash-mode {
      border-left: 3px solid #0092b8;
    }

    .turn.user.bash-mode .turn-role {
      background: #e0f4f8;
      color: #006680;
    }

    .turn.user.slash-command-mode {
      border-left: 3px solid #8b5cf6;
    }

    .turn.user.slash-command-mode .turn-role {
      background: #ede9fe;
      color: #6d28d9;
    }

    .turn.assistant {
      border-left: 3px solid #171717;
      background: white;
    }

    /* Tool calls */
    .tool-calls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--gray-100);
    }

    .tool-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.375rem 0.75rem;
      background: var(--gray-100);
      border-radius: 6px;
      font-size: 0.8125rem;
      cursor: pointer;
      transition: all 0.15s;
      border: 1px solid transparent;
      font-family: inherit;
    }

    .tool-chip:hover {
      background: var(--gray-200);
      border-color: var(--gray-300);
    }

    .tool-chip.expanded {
      background: var(--coral-light);
      border-color: var(--coral);
    }

    .tool-chip.skill-chip {
      background: #FEF3C7;
      border-color: #F59E0B;
    }

    .tool-chip.skill-chip:hover {
      background: #FDE68A;
    }

    .tool-chip.skill-chip.expanded {
      background: #FDE68A;
      border-color: #D97706;
    }

    .tool-chip-icon {
      font-size: 0.875rem;
    }

    .tool-chip-name {
      font-weight: 500;
      color: var(--gray-700);
    }

    .tool-chip-detail {
      color: var(--gray-500);
      max-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Tool expansion */
    .tool-expansion {
      margin-top: 0.75rem;
      padding: 1rem;
      background: var(--gray-50);
      border-radius: 8px;
      border: 1px solid var(--gray-200);
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 0.8125rem;
      overflow-x: auto;
    }

    .tool-expansion-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--gray-200);
    }

    .tool-expansion-title {
      font-weight: 600;
      color: var(--gray-700);
    }

    .tool-expansion-content {
      white-space: pre-wrap;
      word-wrap: break-word;
      color: var(--gray-600);
    }

    .tool-expansion-content.diff .line-add {
      background: #d4edda;
      color: #155724;
    }

    .tool-expansion-content.diff .line-remove {
      background: #f8d7da;
      color: #721c24;
    }

    /* Bash mode terminal styling */
    .bash-terminal {
      background: #1e1e1e;
      border-radius: 8px;
      overflow: hidden;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Consolas', monospace;
      font-size: 0.8125rem;
      margin: 0.5rem 0;
    }

    .bash-terminal-header {
      background: #3c3c3c;
      padding: 0.5rem 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .bash-terminal-dots {
      display: flex;
      gap: 0.375rem;
    }

    .bash-terminal-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .bash-terminal-dot.red { background: #ff5f56; }
    .bash-terminal-dot.yellow { background: #ffbd2e; }
    .bash-terminal-dot.green { background: #27ca40; }

    .bash-terminal-title {
      color: #9d9d9d;
      font-size: 0.75rem;
      margin-left: auto;
    }

    .bash-terminal-body {
      padding: 0.75rem 1rem;
    }

    .bash-command {
      color: #d4d4d4;
      margin-bottom: 0.5rem;
    }

    .bash-command::before {
      content: '$ ';
      color: #6a9955;
    }

    .bash-output {
      color: #9d9d9d;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .bash-output:empty {
      display: none;
    }

    .bash-stderr {
      color: #f48771;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    /* Slash command terminal variant */
    .slash-command-terminal {
      border: 1px solid #8b5cf6;
    }

    .slash-command-terminal .bash-command::before {
      content: '';  /* Command already starts with / */
    }

    .bash-stderr:empty {
      display: none;
    }

    /* Tool result */
    .tool-result {
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px dashed var(--gray-300);
    }

    .tool-result-label {
      font-size: 0.75rem;
      color: var(--gray-400);
      margin-bottom: 0.25rem;
    }

    /* Loading and error states */
    .loading, .error {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--gray-500);
    }

    .error {
      color: var(--coral-dark);
    }

    .no-sessions {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--gray-500);
    }

    .no-sessions code {
      display: block;
      margin-top: 1rem;
      padding: 1rem;
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: 8px;
      font-size: 0.875rem;
    }

    /* Hide tool results by default (they appear in user messages) */
    .turn.user.tool-result-turn {
      display: none;
    }

    .turn.user.tool-result-turn.show-results {
      display: block;
      opacity: 0.7;
      font-size: 0.875rem;
    }

    /* Turn row layout for comments */
    .turn-row {
      position: relative;
    }

    .turn-row .turn {
      width: 100%;
    }

    /* Add comment button (hover reveal) */
    .add-comment-btn {
      opacity: 0;
      transition: opacity 0.2s;
      background: none;
      border: 1px dashed var(--gray-300);
      border-radius: 4px;
      padding: 0.125rem 0.5rem;
      font-size: 0.75rem;
      color: var(--gray-400);
      cursor: pointer;
      margin-left: auto;
    }

    .add-comment-btn:hover {
      border-color: var(--coral);
      color: var(--coral-dark);
      background: var(--coral-light);
    }

    .turn-row:hover .add-comment-btn,
    .turn:hover .add-comment-btn {
      opacity: 1;
    }

    /* Comment card */
    .comment-card {
      position: absolute;
      top: 0;
      left: 100%;
      margin-left: 1rem;
      width: 280px;
      background: var(--coral-light);
      border-left: 3px solid var(--coral);
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    .comment-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .comment-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--coral-dark);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .comment-actions {
      margin-left: auto;
      display: flex;
      gap: 0.25rem;
    }

    .comment-actions button {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.25rem;
      font-size: 0.875rem;
      opacity: 0.6;
      transition: opacity 0.15s;
    }

    .comment-actions button:hover {
      opacity: 1;
    }

    .comment-text {
      font-size: 0.875rem;
      color: var(--gray-700);
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    /* Comment editor */
    .comment-card.editing {
      background: white;
      border-color: var(--coral);
    }

    .comment-editor textarea {
      width: 100%;
      min-height: 80px;
      padding: 0.75rem;
      border: 1px solid var(--gray-300);
      border-radius: 8px;
      font-family: inherit;
      font-size: 0.875rem;
      resize: vertical;
      margin-bottom: 0.5rem;
    }

    .comment-editor textarea:focus {
      outline: none;
      border-color: var(--coral);
      box-shadow: 0 0 0 3px var(--coral-light);
    }

    .comment-editor-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
    }

    .comment-editor-actions button {
      padding: 0.375rem 0.75rem;
      border-radius: 6px;
      font-size: 0.8125rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .comment-editor-actions .save-btn {
      background: var(--coral);
      color: white;
      border: none;
    }

    .comment-editor-actions .save-btn:hover {
      background: var(--coral-dark);
    }

    .comment-editor-actions .cancel-btn {
      background: var(--gray-100);
      color: var(--gray-600);
      border: 1px solid var(--gray-300);
    }

    .comment-editor-actions .cancel-btn:hover {
      background: var(--gray-200);
    }
  </style>
</head>
<body>
  <header class="header">
    <h1>Session Viewer</h1>
    <div class="header-controls">
      <select class="session-select" id="sessionSelect">
        <option value="">Loading sessions...</option>
      </select>
    </div>
  </header>

  <main class="container">
    <div id="content">
      <div class="loading">Loading...</div>
    </div>
  </main>

  <script>
    // State
    let sessions = [];
    let currentSession = null;
    let currentSessionFile = null;
    let expandedTools = new Set();
    let expandedThinking = new Set();
    let sessionComments = {};
    let editingCommentId = null;

    // DOM elements
    const sessionSelect = document.getElementById('sessionSelect');
    const content = document.getElementById('content');

    // Initialize
    async function init() {
      await discoverSessions();
      if (sessions.length > 0) {
        await loadSession(sessions[0]);
      }
    }

    // Discover available session files
    async function discoverSessions() {
      // Try common locations for session files
      const locations = [
        'session-backups/',
        './',
      ];

      const foundSessions = [];

      for (const loc of locations) {
        try {
          // Try to fetch an index or known files
          // Since we can't list directories, we'll try common patterns
          const response = await fetch(loc);
          if (response.ok) {
            const text = await response.text();
            // Parse directory listing if it's an Apache/nginx index
            const matches = text.matchAll(/href="([^"]+\.json)"/g);
            for (const match of matches) {
              const filename = match[1];
              if (!filename.startsWith('.')) {
                foundSessions.push(loc + filename);
              }
            }
          }
        } catch (e) {
          // Ignore errors, location might not exist
        }
      }

      // Also try the example session directly
      try {
        const response = await fetch('example-session.json');
        if (response.ok) {
          foundSessions.push('example-session.json');
        }
      } catch (e) {}

      // Dedupe
      sessions = [...new Set(foundSessions)];

      // Update dropdown
      if (sessions.length === 0) {
        sessionSelect.innerHTML = '<option value="">No sessions found</option>';
        content.innerHTML = `
          <div class="no-sessions">
            <p>No session files found.</p>
            <p>Place JSON session files in this directory or in a <code>session-backups/</code> subdirectory.</p>
            <code>python -m http.server 8000</code>
          </div>
        `;
      } else {
        sessionSelect.innerHTML = sessions.map(s => {
          const name = s.split('/').pop().replace('.json', '');
          return `<option value="${s}">${name}</option>`;
        }).join('');
      }

      // Handle selection changes
      sessionSelect.addEventListener('change', async (e) => {
        if (e.target.value) {
          await loadSession(e.target.value);
        }
      });
    }

    // Load a session file
    async function loadSession(url) {
      content.innerHTML = '<div class="loading">Loading session...</div>';
      expandedTools = new Set();
      expandedThinking = new Set();
      editingCommentId = null;
      currentSessionFile = url;

      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to load: ${response.status}`);

        currentSession = await response.json();
        sessionComments = currentSession.comments || {};
        renderSession();
      } catch (e) {
        content.innerHTML = `<div class="error">Error loading session: ${e.message}</div>`;
      }
    }

    // Render the current session
    function renderSession() {
      if (!currentSession) return;

      const { metadata, summary, conversation } = currentSession;

      // Build HTML
      let html = '';

      // Session metadata
      html += `
        <div class="session-meta">
          <h2>${escapeHtml(metadata.topic || 'Untitled Session')}</h2>
          <div class="meta-row">
            <span>üìÖ ${formatDate(metadata.backupDate || metadata.timestamp)}</span>
            <span>üìÅ ${escapeHtml(metadata.cwd || 'Unknown')}</span>
            ${metadata.gitBranch ? `<span>üåø ${escapeHtml(metadata.gitBranch)}</span>` : ''}
          </div>
          ${summary ? `<div class="summary">${escapeHtml(summary)}</div>` : ''}
        </div>
      `;

      // Timeline
      html += '<div class="timeline">';

      // Process conversation - merge tool results back into assistant turns
      const processedTurns = processConversation(conversation);

      // Group consecutive internal turns into thinking blocks
      let i = 0;
      let thinkingBlockId = 0;
      let turnIndex = 0; // Global index for comment association
      while (i < processedTurns.length) {
        const turn = processedTurns[i];

        if (turn.isInternal) {
          // Collect consecutive internal turns
          const internalTurns = [];
          const internalIndices = [];
          while (i < processedTurns.length && processedTurns[i].isInternal) {
            internalTurns.push(processedTurns[i]);
            internalIndices.push(turnIndex);
            i++;
            turnIndex++;
          }
          // Render as thinking block
          html += renderThinkingBlock(internalTurns, internalIndices, thinkingBlockId);
          thinkingBlockId++;
        } else {
          html += renderTurnRow(turn, turnIndex);
          i++;
          turnIndex++;
        }
      }

      html += '</div>';

      content.innerHTML = html;

      // Update container class based on whether comments exist
      const container = document.querySelector('.container');
      const hasAnyComments = Object.keys(sessionComments).length > 0 || editingCommentId !== null;
      container.classList.toggle('has-comments', hasAnyComments);

      // Attach event listeners for tool chips
      content.querySelectorAll('.tool-chip').forEach(chip => {
        chip.addEventListener('click', () => toggleToolExpansion(chip));
      });

      // Attach event listeners for thinking blocks
      content.querySelectorAll('.thinking-header').forEach(header => {
        header.addEventListener('click', () => toggleThinkingBlock(header));
      });
    }

    // Render a collapsible thinking block
    function renderThinkingBlock(turns, turnIndices, blockId) {
      const isExpanded = expandedThinking.has(blockId);
      const turnCount = turns.length;
      const toolCount = turns.reduce((acc, t) => acc + (t.toolCalls?.length || 0), 0);

      let summary = `${turnCount} internal message${turnCount !== 1 ? 's' : ''}`;
      if (toolCount > 0) {
        summary += `, ${toolCount} tool call${toolCount !== 1 ? 's' : ''}`;
      }

      let html = `
        <div class="thinking-block ${isExpanded ? 'expanded' : ''}" data-block-id="${blockId}">
          <button class="thinking-header">
            <span class="thinking-icon">${isExpanded ? '‚ñº' : '‚ñ∂'}</span>
            <span class="thinking-label">${isExpanded ? 'Hide' : 'Show'} thinking</span>
            <span class="thinking-summary">${summary}</span>
          </button>
      `;

      if (isExpanded) {
        html += '<div class="thinking-content">';
        for (let i = 0; i < turns.length; i++) {
          html += renderTurnRow(turns[i], turnIndices[i]);
        }
        html += '</div>';
      }

      html += '</div>';
      return html;
    }

    // Toggle thinking block expansion
    function toggleThinkingBlock(header) {
      const block = header.closest('.thinking-block');
      const blockId = parseInt(block.dataset.blockId, 10);

      if (expandedThinking.has(blockId)) {
        expandedThinking.delete(blockId);
      } else {
        expandedThinking.add(blockId);
      }

      renderSession();
    }

    // Process conversation to group tool calls with their results
    function processConversation(conversation) {
      const turns = [];
      let pendingToolCalls = new Map(); // tool_use_id -> tool_use object

      // First pass: merge assistant messages with the same message ID
      // Claude Code records each streaming chunk as a separate entry
      // Also track command/meta messages to attach to the turn that called the Skill tool
      const mergedMessages = [];
      const assistantMessageMap = new Map(); // message.id -> merged message
      let lastSkillCallerMsg = null; // The assistant message that called a Skill tool
      let pendingSkillContext = null; // { name, prompt } to attach
      let pendingSlashCommand = null; // Command name for local commands like /clear

      for (const msg of conversation) {
        // Skip non-message entries (file-history-snapshot, etc.)
        if (msg.type !== 'user' && msg.type !== 'assistant') {
          continue;
        }

        if (msg.type === 'assistant') {
          const msgId = msg.message?.id;
          if (msgId && assistantMessageMap.has(msgId)) {
            // Merge content into existing message
            const existing = assistantMessageMap.get(msgId);
            const newContent = msg.message?.content || [];
            if (Array.isArray(newContent)) {
              existing.message.content.push(...newContent);
              // Check if this chunk has a Skill tool call
              for (const item of newContent) {
                if (item.type === 'tool_use' && item.name === 'Skill') {
                  lastSkillCallerMsg = existing;
                }
              }
            }
            // Update stop_reason to latest (final chunk has the real reason)
            if (msg.message?.stop_reason) {
              existing.stopReason = msg.message.stop_reason;
            }
          } else {
            // New assistant message
            const cloned = JSON.parse(JSON.stringify(msg));
            // Ensure content is an array
            if (typeof cloned.message?.content === 'string') {
              cloned.message.content = [{ type: 'text', text: cloned.message.content }];
            } else if (!Array.isArray(cloned.message?.content)) {
              cloned.message.content = [];
            }
            // Track stop_reason (will be updated if more chunks come)
            cloned.stopReason = msg.message?.stop_reason;
            // Check if this message has a Skill tool call
            for (const item of cloned.message.content) {
              if (item.type === 'tool_use' && item.name === 'Skill') {
                lastSkillCallerMsg = cloned;
              }
            }
            mergedMessages.push(cloned);
            if (msgId) {
              assistantMessageMap.set(msgId, cloned);
            }
          }
        } else {
          // User message - check for command/meta messages
          const content = msg.message?.content;

          // Capture command invocation markers
          if (typeof content === 'string' && content.includes('<command-message>')) {
            const nameMatch = content.match(/<command-name>([^<]+)<\/command-name>/);
            const commandName = nameMatch ? nameMatch[1] : 'Unknown';
            // Store for both skill context and slash commands
            pendingSkillContext = { name: commandName, prompt: null };
            pendingSlashCommand = commandName;
            continue;
          }

          // Check for local command output (like /clear)
          if (typeof content === 'string' && content.includes('<local-command-stdout>')) {
            // Attach the pending slash command name to this message
            const cloned = JSON.parse(JSON.stringify(msg));
            cloned.slashCommandName = pendingSlashCommand;
            pendingSlashCommand = null;
            pendingSkillContext = null; // Clear skill context since this is a local command
            mergedMessages.push(cloned);
            continue;
          }

          // Capture meta messages (skill prompts)
          if (msg.isMeta) {
            // Extract text content from the meta message
            let promptText = '';
            if (typeof content === 'string') {
              promptText = content;
            } else if (Array.isArray(content)) {
              promptText = content
                .filter(item => item.type === 'text')
                .map(item => item.text)
                .join('\n');
            }

            if (pendingSkillContext) {
              pendingSkillContext.prompt = promptText;
            }

            // Attach to the message that called the Skill tool
            if (lastSkillCallerMsg && pendingSkillContext) {
              lastSkillCallerMsg.skillContext = pendingSkillContext;
              pendingSkillContext = null;
              lastSkillCallerMsg = null;
            }
            continue;
          }

          mergedMessages.push(msg);
        }
      }

      // Second pass: process merged messages into turns
      for (const msg of mergedMessages) {
        const role = msg.type;
        // Handle content being either a string or an array
        let msgContent = msg.message?.content || [];
        if (typeof msgContent === 'string') {
          msgContent = [{ type: 'text', text: msgContent }];
        }

        if (role === 'assistant') {
          const turn = {
            role: 'assistant',
            timestamp: msg.timestamp,
            text: '',
            toolCalls: [],
            images: [],
            skillContext: msg.skillContext || null,
            isInternal: msg.stopReason === 'tool_use'
          };

          for (const item of msgContent) {
            if (item.type === 'text') {
              turn.text += item.text;
            } else if (item.type === 'image' && item.source) {
              turn.images.push(item.source);
            } else if (item.type === 'tool_use') {
              const toolCall = {
                id: item.id,
                name: item.name,
                input: item.input,
                result: null
              };
              turn.toolCalls.push(toolCall);
              pendingToolCalls.set(item.id, toolCall);
            }
          }

          if (turn.text || turn.toolCalls.length > 0 || turn.images.length > 0) {
            turns.push(turn);
          }
        } else if (role === 'user') {
          // Check if this is just tool results or actual user input
          let hasUserContent = false;
          let userText = '';
          let userImages = [];

          for (const item of msgContent) {
            if (item.type === 'text') {
              hasUserContent = true;
              userText += item.text;
            } else if (item.type === 'image' && item.source) {
              hasUserContent = true;
              userImages.push(item.source);
            } else if (item.type === 'tool_result') {
              // Attach result to pending tool call
              const toolCall = pendingToolCalls.get(item.tool_use_id);
              if (toolCall) {
                toolCall.result = item.content;
              }
            }
          }

          if (hasUserContent && (userText.trim() || userImages.length > 0)) {
            const turn = {
              role: 'user',
              timestamp: msg.timestamp,
              text: userText,
              images: userImages
            };
            // Attach slash command name if present
            if (msg.slashCommandName) {
              turn.slashCommandName = msg.slashCommandName;
            }
            turns.push(turn);
          }
        }
      }

      // Post-process: merge bash-input/bash-stdout/bash-stderr consecutive user turns
      const mergedTurns = [];
      let i = 0;
      while (i < turns.length) {
        const turn = turns[i];

        // Check if this is a user turn with bash-input
        const inputMatch = turn.role === 'user' ? turn.text.match(/<bash-input>([\s\S]*?)<\/bash-input>/) : null;
        if (inputMatch) {
          // Start a bash session - collect this and following stdout/stderr turns
          const bashCommands = [{
            command: inputMatch[1].trim(),
            stdout: '',
            stderr: ''
          }];
          i++; // Move past the first bash-input turn

          while (i < turns.length && turns[i].role === 'user') {
            const currentText = turns[i].text;

            // Check for bash-input (new command)
            const nextInputMatch = currentText.match(/<bash-input>([\s\S]*?)<\/bash-input>/);
            if (nextInputMatch) {
              bashCommands.push({
                command: nextInputMatch[1].trim(),
                stdout: '',
                stderr: ''
              });
              i++;
              continue;
            }

            // Check for bash-stdout (output for last command)
            const stdoutMatch = currentText.match(/<bash-stdout>([\s\S]*?)<\/bash-stdout>/);
            if (stdoutMatch && bashCommands.length > 0) {
              bashCommands[bashCommands.length - 1].stdout = stdoutMatch[1].trim();
              i++;
              continue;
            }

            // Check for bash-stderr (error for last command)
            const stderrMatch = currentText.match(/<bash-stderr>([\s\S]*?)<\/bash-stderr>/);
            if (stderrMatch && bashCommands.length > 0) {
              bashCommands[bashCommands.length - 1].stderr = stderrMatch[1].trim();
              i++;
              continue;
            }

            // Not a bash-related turn, stop collecting
            break;
          }

          // Create a merged bash turn
          mergedTurns.push({
            role: 'user',
            timestamp: turn.timestamp,
            text: '',
            images: turn.images || [],
            bashCommands: bashCommands
          });
        } else {
          // Check if this is a user turn with slash command (has slashCommandName from earlier processing)
          const hasSlashCommand = turn.role === 'user' && turn.slashCommandName;

          if (hasSlashCommand) {
            // Extract stdout from the content
            const stdoutMatch = turn.text.match(/<local-command-stdout>([\s\S]*?)<\/local-command-stdout>/);
            const stdout = stdoutMatch ? stdoutMatch[1].trim() : '';

            // Create a slash command turn
            mergedTurns.push({
              role: 'user',
              timestamp: turn.timestamp,
              text: '',
              images: turn.images || [],
              slashCommands: [{
                command: turn.slashCommandName,
                stdout: stdout
              }]
            });
            i++;
          } else {
            mergedTurns.push(turn);
            i++;
          }
        }
      }

      return mergedTurns;
    }

    // Render a single turn
    function renderTurn(turn, turnIndex) {
      const isBashTurn = turn.bashCommands && turn.bashCommands.length > 0;
      const isSlashCommandTurn = turn.slashCommands && turn.slashCommands.length > 0;
      const roleClass = isSlashCommandTurn ? 'user slash-command-mode' : (isBashTurn ? 'user bash-mode' : turn.role);
      const roleLabel = turn.role === 'assistant' ? 'AI' : (isSlashCommandTurn ? 'Slash Command' : (isBashTurn ? 'Bash' : 'User'));
      const internalClass = turn.isInternal ? 'internal' : '';
      const turnId = turnIndex !== undefined ? `turn-${turnIndex}` : null;

      // Strip image metadata text if turn has images
      let displayText = turn.text;
      if (turn.images && turn.images.length > 0) {
        displayText = displayText.replace(/\[Image: original \d+x\d+, displayed at \d+x\d+\. Multiply coordinates by [\d.]+ to map to original image\.\]/g, '').trim();
      }

      // Check for bash mode content in user turns
      let contentHtml;

      // First check for pre-merged slash commands (from processConversation)
      if (turn.slashCommands && turn.slashCommands.length > 0) {
        contentHtml = renderSlashCommandSession(turn.slashCommands);
      } else if (turn.bashCommands && turn.bashCommands.length > 0) {
        // Check for pre-merged bash commands (from processConversation)
        contentHtml = renderBashSession(turn.bashCommands);
      } else {
        // Fall back to inline parsing for any remaining cases
        const bashBlocks = turn.role === 'user' ? formatBashMode(displayText) : null;

        if (bashBlocks) {
          contentHtml = bashBlocks.map(block => {
            if (block.type === 'bash') {
              return renderBashTerminal(block.command, block.stdout, block.stderr);
            } else {
              return `<div class="turn-content">${escapeHtml(block.content)}</div>`;
            }
          }).join('');
        } else {
          contentHtml = `<div class="turn-content">${escapeHtml(displayText)}</div>`;
        }
      }

      let html = `
        <div class="turn ${roleClass} ${internalClass}">
          <div class="turn-header">
            <span class="turn-role">${roleLabel}</span>
            ${turn.isInternal ? '<span class="internal-badge">internal</span>' : ''}
            ${turn.skillContext ? `<span class="skill-badge">${escapeHtml(turn.skillContext.name)}</span>` : ''}
            ${turnId ? `<button class="add-comment-btn" onclick="addComment('${turnId}')">+ Note</button>` : ''}
          </div>
          ${contentHtml}
      `;

      // Render images if present
      if (turn.images && turn.images.length > 0) {
        html += '<div class="turn-images">';
        for (const img of turn.images) {
          const mediaType = img.media_type || 'image/png';
          const data = img.data || '';
          html += `<img class="turn-image" src="data:${mediaType};base64,${data}" alt="Uploaded image" onclick="window.open(this.src, '_blank')">`;
        }
        html += '</div>';
      }

      // Skill context and tool calls
      const hasSkill = turn.skillContext && turn.skillContext.prompt;
      const hasTools = turn.toolCalls && turn.toolCalls.length > 0;

      if (hasSkill || hasTools) {
        html += '<div class="tool-calls">';

        // Tool call chips first
        if (hasTools) {
          for (const tool of turn.toolCalls) {
            html += renderToolChip(tool);
          }
        }

        // Skill context chip (after tool chips, to the right)
        if (hasSkill) {
          const skillId = 'skill-' + turn.timestamp;
          const expanded = expandedTools.has(skillId) ? 'expanded' : '';
          html += `
            <button class="tool-chip skill-chip ${expanded}" data-tool-id="${skillId}">
              <span class="tool-chip-icon">‚ö°</span>
              <span class="tool-chip-name">Skill Prompt</span>
              <span class="tool-chip-detail">${escapeHtml(turn.skillContext.name)}</span>
            </button>
          `;
        }
        html += '</div>';

        // Expanded skill prompt
        if (hasSkill && expandedTools.has('skill-' + turn.timestamp)) {
          html += `
            <div class="tool-expansion">
              <div class="tool-expansion-header">
                <span class="tool-expansion-title">Skill: ${escapeHtml(turn.skillContext.name)}</span>
              </div>
              <div class="tool-expansion-content">${escapeHtml(turn.skillContext.prompt)}</div>
            </div>
          `;
        }

        // Expanded tool details
        if (hasTools) {
          for (const tool of turn.toolCalls) {
            if (expandedTools.has(tool.id)) {
              html += renderToolExpansion(tool);
            }
          }
        }
      }

      html += '</div>';
      return html;
    }

    // Render a tool chip
    function renderToolChip(tool) {
      const icon = getToolIcon(tool.name);
      const detail = getToolDetail(tool);
      const expanded = expandedTools.has(tool.id) ? 'expanded' : '';

      return `
        <button class="tool-chip ${expanded}" data-tool-id="${tool.id}">
          <span class="tool-chip-icon">${icon}</span>
          <span class="tool-chip-name">${tool.name}</span>
          <span class="tool-chip-detail">${escapeHtml(detail)}</span>
        </button>
      `;
    }

    // Get icon for tool type
    function getToolIcon(toolName) {
      const icons = {
        'Read': 'üìñ',
        'Edit': '‚úèÔ∏è',
        'Write': 'üìù',
        'Bash': '‚ñ∂Ô∏è',
        'Grep': 'üîç',
        'Glob': 'üìÇ',
        'WebFetch': 'üåê',
        'WebSearch': 'üîé',
        'Task': 'ü§ñ',
        'TodoWrite': '‚òëÔ∏è'
      };
      return icons[toolName] || 'üîß';
    }

    // Get short detail for tool chip
    function getToolDetail(tool) {
      const input = tool.input || {};

      switch (tool.name) {
        case 'Read':
          return shortenPath(input.file_path);
        case 'Edit':
        case 'Write':
          return shortenPath(input.file_path);
        case 'Bash':
          return truncate(input.command, 40);
        case 'Grep':
          return input.pattern || '';
        case 'Glob':
          return input.pattern || '';
        default:
          return '';
      }
    }

    // Render expanded tool details
    function renderToolExpansion(tool) {
      const input = tool.input || {};
      let content = '';
      let title = tool.name;

      switch (tool.name) {
        case 'Read':
          title = `Read: ${input.file_path || 'file'}`;
          content = tool.result || '(no content)';
          break;
        case 'Edit':
          title = `Edit: ${input.file_path || 'file'}`;
          content = formatDiff(input.old_string, input.new_string);
          break;
        case 'Write':
          title = `Write: ${input.file_path || 'file'}`;
          content = input.content || '(no content)';
          break;
        case 'Bash':
          title = `Bash: ${truncate(input.command, 60)}`;
          content = `$ ${input.command}\n\n${tool.result || '(no output)'}`;
          break;
        default:
          content = JSON.stringify(input, null, 2);
          if (tool.result) {
            content += '\n\n--- Result ---\n' +
              (typeof tool.result === 'string' ? tool.result : JSON.stringify(tool.result, null, 2));
          }
      }

      return `
        <div class="tool-expansion" data-tool-id="${tool.id}">
          <div class="tool-expansion-header">
            <span class="tool-expansion-title">${escapeHtml(title)}</span>
          </div>
          <div class="tool-expansion-content">${escapeHtml(content)}</div>
        </div>
      `;
    }

    // Format bash mode content (user turns with ! commands)
    function formatBashMode(text) {
      // Check if text contains bash-input tags
      if (!text.includes('<bash-input>')) {
        return null;
      }

      const blocks = [];

      // Parse all bash-input with optional stdout/stderr
      const bashPattern = /<bash-input>([\s\S]*?)<\/bash-input>(?:\s*<bash-stdout>([\s\S]*?)<\/bash-stdout>)?(?:\s*<bash-stderr>([\s\S]*?)<\/bash-stderr>)?/g;
      let match;
      let lastIndex = 0;

      while ((match = bashPattern.exec(text)) !== null) {
        // Add any text before this match as regular content
        const before = text.slice(lastIndex, match.index).trim();
        if (before) {
          blocks.push({ type: 'text', content: before });
        }

        blocks.push({
          type: 'bash',
          command: match[1].trim(),
          stdout: match[2] ? match[2].trim() : '',
          stderr: match[3] ? match[3].trim() : ''
        });

        lastIndex = match.index + match[0].length;
      }

      // Add any remaining text after last match
      const after = text.slice(lastIndex).trim();
      if (after) {
        blocks.push({ type: 'text', content: after });
      }

      if (blocks.length === 0 || !blocks.some(b => b.type === 'bash')) {
        return null;
      }

      return blocks;
    }

    // Render bash terminal block for a single command
    function renderBashTerminal(command, stdout, stderr) {
      return `
        <div class="bash-terminal">
          <div class="bash-terminal-header">
            <div class="bash-terminal-dots">
              <span class="bash-terminal-dot red"></span>
              <span class="bash-terminal-dot yellow"></span>
              <span class="bash-terminal-dot green"></span>
            </div>
            <span class="bash-terminal-title">bash</span>
          </div>
          <div class="bash-terminal-body">
            <div class="bash-command">${escapeHtml(command)}</div>
            <div class="bash-output">${escapeHtml(stdout)}</div>
            <div class="bash-stderr">${escapeHtml(stderr)}</div>
          </div>
        </div>
      `;
    }

    // Render a bash session with multiple commands in one terminal
    function renderBashSession(commands) {
      const commandsHtml = commands.map(cmd => `
        <div class="bash-command">${escapeHtml(cmd.command)}</div>
        <div class="bash-output">${escapeHtml(cmd.stdout)}</div>
        <div class="bash-stderr">${escapeHtml(cmd.stderr)}</div>
      `).join('');

      return `
        <div class="bash-terminal">
          <div class="bash-terminal-header">
            <div class="bash-terminal-dots">
              <span class="bash-terminal-dot red"></span>
              <span class="bash-terminal-dot yellow"></span>
              <span class="bash-terminal-dot green"></span>
            </div>
            <span class="bash-terminal-title">bash</span>
          </div>
          <div class="bash-terminal-body">
            ${commandsHtml}
          </div>
        </div>
      `;
    }

    // Render a slash command session
    function renderSlashCommandSession(commands) {
      const commandsHtml = commands.map(cmd => `
        <div class="bash-command">${escapeHtml(cmd.command)}</div>
        ${cmd.stdout ? `<div class="bash-output">${escapeHtml(cmd.stdout)}</div>` : ''}
      `).join('');

      return `
        <div class="bash-terminal slash-command-terminal">
          <div class="bash-terminal-header">
            <div class="bash-terminal-dots">
              <span class="bash-terminal-dot red"></span>
              <span class="bash-terminal-dot yellow"></span>
              <span class="bash-terminal-dot green"></span>
            </div>
            <span class="bash-terminal-title">Slash Command</span>
          </div>
          <div class="bash-terminal-body">
            ${commandsHtml}
          </div>
        </div>
      `;
    }

    // Format a diff from old/new strings
    function formatDiff(oldStr, newStr) {
      if (!oldStr && !newStr) return '(no changes)';

      let diff = '';
      if (oldStr) {
        diff += '--- old\n';
        diff += oldStr.split('\n').map(l => '- ' + l).join('\n');
      }
      if (newStr) {
        diff += '\n+++ new\n';
        diff += newStr.split('\n').map(l => '+ ' + l).join('\n');
      }
      return diff;
    }

    // Toggle tool expansion
    function toggleToolExpansion(chip) {
      const toolId = chip.dataset.toolId;

      if (expandedTools.has(toolId)) {
        expandedTools.delete(toolId);
      } else {
        expandedTools.add(toolId);
      }

      renderSession();
    }

    // Comment system functions

    // Render a turn with optional comment card
    function renderTurnRow(turn, turnIndex) {
      const turnId = `turn-${turnIndex}`;
      const comment = sessionComments[turnId];
      const hasComment = !!comment || editingCommentId === turnId;

      return `
        <div class="turn-row" data-turn-index="${turnIndex}">
          ${renderTurn(turn, turnIndex)}
          ${hasComment ? renderCommentCard(turnId, comment) : ''}
        </div>
      `;
    }

    // Render a comment card (display or editor mode)
    function renderCommentCard(turnId, text) {
      if (editingCommentId === turnId) {
        return renderCommentEditor(turnId, text || '');
      }

      return `
        <div class="comment-card" data-turn-id="${turnId}">
          <div class="comment-header">
            <span class="comment-label">Note</span>
            <div class="comment-actions">
              <button onclick="editComment('${turnId}')" title="Edit">‚úèÔ∏è</button>
              <button onclick="deleteComment('${turnId}')" title="Delete">üóëÔ∏è</button>
            </div>
          </div>
          <div class="comment-text">${escapeHtml(text)}</div>
        </div>
      `;
    }

    // Render comment editor
    function renderCommentEditor(turnId, existingText) {
      return `
        <div class="comment-card editing" data-turn-id="${turnId}">
          <div class="comment-editor">
            <textarea id="comment-input-${turnId}" placeholder="Add your note here...">${escapeHtml(existingText)}</textarea>
            <div class="comment-editor-actions">
              <button class="cancel-btn" onclick="cancelCommentEdit()">Cancel</button>
              <button class="save-btn" onclick="saveComment('${turnId}')">Save</button>
            </div>
          </div>
        </div>
      `;
    }

    // Add a new comment
    function addComment(turnId) {
      editingCommentId = turnId;
      renderSession();

      // Focus the textarea after render
      setTimeout(() => {
        const textarea = document.getElementById(`comment-input-${turnId}`);
        if (textarea) textarea.focus();
      }, 0);
    }

    // Edit an existing comment
    function editComment(turnId) {
      editingCommentId = turnId;
      renderSession();

      setTimeout(() => {
        const textarea = document.getElementById(`comment-input-${turnId}`);
        if (textarea) {
          textarea.focus();
          textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }
      }, 0);
    }

    // Delete a comment
    async function deleteComment(turnId) {
      if (!confirm('Delete this note?')) return;

      delete sessionComments[turnId];
      await persistComments();
      renderSession();
    }

    // Save a comment
    async function saveComment(turnId) {
      const textarea = document.getElementById(`comment-input-${turnId}`);
      if (!textarea) return;

      const text = textarea.value.trim();

      if (text) {
        sessionComments[turnId] = text;
      } else {
        delete sessionComments[turnId];
      }

      editingCommentId = null;
      await persistComments();
      renderSession();
    }

    // Cancel editing
    function cancelCommentEdit() {
      editingCommentId = null;
      renderSession();
    }

    // Persist comments to server
    async function persistComments() {
      if (!currentSessionFile) return;

      try {
        const response = await fetch('/save-comments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionFile: currentSessionFile,
            comments: sessionComments
          })
        });

        if (!response.ok) {
          const error = await response.text();
          console.error('Failed to save comments:', error);
          alert('Failed to save note. Please try again.');
        }
      } catch (e) {
        console.error('Failed to save comments:', e);
        alert('Failed to save note. Is the server running?');
      }
    }

    // Utility functions
    function escapeHtml(str) {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    function formatDate(dateStr) {
      if (!dateStr) return '';
      const date = new Date(dateStr);
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function formatTime(dateStr) {
      if (!dateStr) return '';
      const date = new Date(dateStr);
      return date.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
    }

    function shortenPath(path) {
      if (!path) return '';
      const parts = path.split('/');
      if (parts.length <= 2) return path;
      return '.../' + parts.slice(-2).join('/');
    }

    function truncate(str, len) {
      if (!str) return '';
      if (str.length <= len) return str;
      return str.substring(0, len) + '...';
    }

    // Start the app
    init();
  </script>
</body>
</html>
